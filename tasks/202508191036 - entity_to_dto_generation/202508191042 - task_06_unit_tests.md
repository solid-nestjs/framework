# Task 6: Create Unit Tests

**Feature**: Entity-to-DTO Code Generation  
**Task ID**: 202508191042  
**Status**: Pending  
**Estimated Time**: 3 hours  
**Dependencies**: Task 5  

## Objective

Create comprehensive unit tests for the GenerateDtoFromEntity helper and all supporting functions.

## Requirements

1. **Test File Location**: `packages-core/common/src/helpers/__tests__/generate-dto-from-entity.spec.ts`

2. **Test Coverage**:
   - Property selection logic
   - Type filtering (flat vs complex)
   - Decorator transfer
   - Validation inference
   - Error handling
   - Edge cases

## Test Cases

### 1. Basic Functionality Tests

```typescript
describe('GenerateDtoFromEntity', () => {
  describe('Property Selection', () => {
    it('should select specified properties', () => {
      class TestEntity {
        @SolidId() id: string;
        @SolidField() name: string;
        @SolidField() description: string;
        @SolidField() price: number;
      }
      
      const DtoClass = GenerateDtoFromEntity(TestEntity, ['name', 'price']);
      const instance = new DtoClass();
      
      expect(instance).toHaveProperty('name');
      expect(instance).toHaveProperty('price');
      expect(instance).not.toHaveProperty('description');
      expect(instance).not.toHaveProperty('id');
    });
    
    it('should select all flat properties by default', () => {
      // Test default behavior
    });
    
    it('should exclude id by default', () => {
      // Test id exclusion
    });
    
    it('should exclude timestamps by default', () => {
      // Test timestamp exclusion
    });
  });
});
```

### 2. Type Filtering Tests

```typescript
describe('Type Filtering', () => {
  it('should include flat types', () => {
    // Test string, number, boolean, Date
  });
  
  it('should exclude arrays', () => {
    // Test array exclusion
  });
  
  it('should exclude objects/relations', () => {
    // Test relation exclusion
  });
  
  it('should throw error when selecting non-flat property', () => {
    // Test error for complex type selection
  });
});
```

### 3. Decorator Transfer Tests

```typescript
describe('Decorator Transfer', () => {
  it('should transfer @SolidField configurations', () => {
    // Test description, constraints transfer
  });
  
  it('should remove TypeORM configurations', () => {
    // Test TypeORM config removal
  });
  
  it('should preserve GraphQL configurations', () => {
    // Test GraphQL config preservation
  });
  
  it('should preserve validation options', () => {
    // Test validation option preservation
  });
});
```

### 4. Validation Inference Tests

```typescript
describe('Validation Inference', () => {
  it('should apply validation based on type', () => {
    // Test automatic validation decorators
  });
  
  it('should handle optional fields', () => {
    // Test @IsOptional() application
  });
  
  it('should apply special validations', () => {
    // Test email, url, uuid validations
  });
  
  it('should apply constraint validations', () => {
    // Test min, max, minLength, maxLength
  });
});
```

### 5. Error Handling Tests

```typescript
describe('Error Handling', () => {
  it('should throw error for non-existent property', () => {
    expect(() => {
      GenerateDtoFromEntity(TestEntity, ['nonExistent']);
    }).toThrow("Property 'nonExistent' does not exist");
  });
  
  it('should throw error for non-flat property selection', () => {
    // Test error for complex property
  });
});
```

### 6. Integration Tests

```typescript
describe('Integration', () => {
  it('should work with class inheritance', () => {
    // Test extending generated DTO
  });
  
  it('should work with @SolidInput decorator', () => {
    // Test with actual decorator application
  });
  
  it('should work with ValidationPipe', () => {
    // Test validation actually works
  });
});
```

## Test Utilities

Create helper functions for tests:

```typescript
function createTestEntity() {
  @SolidEntity()
  class TestEntity {
    @SolidId() id: string;
    @SolidField({ description: 'Name', minLength: 3 }) name: string;
    @SolidField({ description: 'Price', positive: true }) price: number;
    @SolidField({ nullable: true }) description?: string;
    @SolidManyToOne(() => OtherEntity) relation: OtherEntity;
  }
  return TestEntity;
}
```

## Success Criteria

- [ ] All test cases pass
- [ ] Code coverage > 90%
- [ ] Edge cases covered
- [ ] Error scenarios tested
- [ ] Integration with existing system verified